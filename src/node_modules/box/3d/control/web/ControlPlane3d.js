import React, { Component } from 'react'
import compose              from 'recompose/compose'
import defaultProps         from 'recompose/defaultProps'
import lifecycle            from 'recompose/lifecycle'
import withHandlers         from 'recompose/withHandlers'
import withPropsOnChange    from 'recompose/withPropsOnChange'
import withStateHandlers    from 'recompose/withStateHandlers'

import * as THREE           from 'three'


import Context              from '../../scene/all/Context'


const MOUSE_RIGHT = 2

const enhance = compose(
  defaultProps({
    x: 0,
    y: 0,
    z: 0,
    distanceMin: 10,
    distanceMax: 60,
    zoomSpeed: 1.0,
  }),
  withStateHandlers(() => ({
  }), {
  }),
  withHandlers(({
  }) => {
    let dragType = null
    const panStart = new THREE.Vector2()
    const panEnd = new THREE.Vector2()
    const panDelta = new THREE.Vector2()

    return {
      onMouseDown: () => (e) => {
        e.preventDefault()
        e.stopPropagation()

        if (e.button === MOUSE_RIGHT) {
          const { clientX, clientY } = e
          dragType = `pan`
          panStart.set(e.clientX, e.clientY)
        }
      },
      onMouseMove: ({
        camera,
        fromScene,
        intersectCheckList,
        positionSet,
        x, y, z,
      }) => (e) => {
        e.preventDefault()

        if (dragType === `pan`) {
          panEnd.set(e.clientX, e.clientY)
          panDelta.subVectors(panEnd, panStart)
          panStart.copy(panEnd)

          positionSet(
            x - panDelta.x * 0.05,
            y + panDelta.y * 0.05,
            z,
          )
        }
      },
      onMouseUp: () => (e) => {
        dragType = null
      },
      onMouseWheel: ({
        camera,
        distanceMin,
        distanceMax,
        positionSet,
        x, y, z,
        onZoom,
      }) => (e) => {
        e.preventDefault()
        e.stopPropagation()

        const { deltaY } = e

        const offset = deltaY * 0.05
        const z1 = z + offset
        const currentDistance = z1 < distanceMin
          ? distanceMin
          : z1 > distanceMax
            ? distanceMax
            : z1
        
        positionSet(
          x,
          y,
          currentDistance
        )

        const distanceMaxNormal = distanceMax - distanceMin
        const distanceCurrentNormal = currentDistance - distanceMin
        const zoom = distanceCurrentNormal / distanceMaxNormal

        onZoom && onZoom(zoom)
      },
    }
  }),
  withHandlers(() => {
    let controls

    return {
      mount: ({
        fromScene: {
          container,
        },
        onMouseDown,
        onMouseMove,
        onMouseUp,
        onMouseWheel,        
      }) => () => {
        container.addEventListener('mousedown', onMouseDown, false)
        container.addEventListener('mousemove', onMouseMove, false)
        container.addEventListener('mouseup', onMouseUp, false)
        container.addEventListener('wheel', onMouseWheel, false)
      },
      unmount: ({
        fromScene: {
          container,
        },
        onMouseDown,
        onMouseMove,
        onMouseUp,
        onMouseWheel,
      }) => () => {
        container.removeEventListener('mousedown', onMouseDown, false)
        container.removeEventListener('mousemove', onMouseMove, false)
        container.removeEventListener('mouseup', onMouseUp, false)
        container.removeEventListener('wheel', onMouseWheel, false)        
      },
    }
  }),
  // withPropsOnChange(
  //   [`plane`],
  //   ({ camera, control, plane, positionSet, lookAt }) => {
  //     if (control === `plane` && plane) {
  //       positionSet(0, 0, 60)
  //       lookAt(plane)
  //     }
  //   }
  // ),
  lifecycle({
    componentDidMount() {
      this.props.mount()
    },
    componentWillUnmount() {
      this.props.unmount()
    }
  }),
)

const ControlPlane3d = enhance(() => null)

export default (props) => {
  return (
    <Context.Consumer>
      {(context) => (
        <ControlPlane3d
          {...props}
          fromScene={context}
        />
      )}
    </Context.Consumer>
  )
}