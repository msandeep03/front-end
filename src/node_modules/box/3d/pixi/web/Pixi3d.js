import React, { Component } from 'react'
import compose              from 'recompose/compose'
import defaultProps         from 'recompose/defaultProps'
import withHandlers         from 'recompose/withHandlers'
import withPropsOnChange    from 'recompose/withPropsOnChange'
import withStateHandlers    from 'recompose/withStateHandlers'
import lifecycle            from 'recompose/lifecycle'

import * as PIXI            from 'pixi.js'
import * as PIXIL           from 'pixi-layers'
import * as PIXIF           from 'pixi-filters'
import * as THREE           from 'three'


import Context              from 'box/2d/stage/all/Context'
import withScene            from '../../scene/all/withScene'


function patchRenderTarget(renderer) {
  PIXI.RenderTarget.prototype.calculateProjection = function (destinationFrame, sourceFrame) {
    const pm = this.projectionMatrix
    sourceFrame = sourceFrame || destinationFrame

    pm.identity()

    pm.a = 1 / destinationFrame.width * 2
    pm.d = -1 / destinationFrame.height * 2

    pm.tx = -1 - (sourceFrame.x * pm.a)
    pm.ty = 1 - (sourceFrame.y * pm.d)
  }

  renderer.filterManager.quad.map = function (targetTextureFrame, destinationFrame) {
    let x = 0
    let y = 0

    this.uvs[0] = x
    this.uvs[1] = y + (destinationFrame.height / targetTextureFrame.height)

    this.uvs[2] = x + (destinationFrame.width / targetTextureFrame.width)
    this.uvs[3] = y + (destinationFrame.height / targetTextureFrame.height)

    this.uvs[4] = x + (destinationFrame.width / targetTextureFrame.width)
    this.uvs[5] = y

    this.uvs[6] = x
    this.uvs[7] = y

    x = destinationFrame.x
    y = destinationFrame.y

    this.vertices[0] = x
    this.vertices[1] = y

    this.vertices[2] = x + destinationFrame.width
    this.vertices[3] = y

    this.vertices[4] = x + destinationFrame.width
    this.vertices[5] = y + destinationFrame.height

    this.vertices[6] = x
    this.vertices[7] = y + destinationFrame.height

    return this
  }
}

const enhance = compose(
  withScene(),
  defaultProps({
    antialias: true,
    backgroundColor: 0xffffff,
    transparent: false,
    width: 2048,
    height: 2048,
  }),
  withStateHandlers(
    () => ({
      stage: null,
      canvas: null,
      layers: {},  
      renderer: null,    
      textures: {},
    }),
    {
      stageSet: () => (stage) => ({ stage }),
      canvasSet: () => (canvas) => ({ canvas }),
      layerSet: ({ layers }) => ({ name, value }) => {
        return {
          layers: {
            ...layers,
            [name]: value,
          },
        }
      },
      layerUnset: ({ layers: prevLayers }) => ({ name }) => {
        const { [name]: layerRemove, ...layers } = prevLayers
        return { layers }
      },
      rendererSet: () => (renderer) => ({ renderer }),
      textureSet: ({ textures }) => async ({ name, value }) => {
        return {
          textures: {
            ...textures,
            [name]: value,
          }
        }
      },
    }
  ),
  withHandlers({
    animate: ({ texture }) => () => {
    }
  }),
  withHandlers({
    mount4: ({
      fromScene,
      width,
      height,
    }) => () => {
      const { animateAdd, renderer, scene } = fromScene

      const pixiRenderer = new PIXI.WebGLRenderer(width, height, {
        view: renderer.domElement,
        context: renderer.context,
      })
      pixiRenderer.clearBeforeRender = false

      const stage = new PIXI.Container()
      const sprite = PIXI.Sprite.fromImage('https://cdn.evokeme.io/static/3d/box.jpg')
      stage.addChild(sprite)

      const camera = new THREE.PerspectiveCamera(70, width / height, 1, 1000)

      const bufferScene = new THREE.Scene()
      const bufferTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter})
      var redMaterial = new THREE.MeshBasicMaterial({ color: 0xF06565 })
      var boxGeometry = new THREE.BoxGeometry(5, 5, 5)
      var boxObject = new THREE.Mesh(boxGeometry, redMaterial)
      boxObject.position.z = -10;
      bufferScene.add(boxObject)

      var blueMaterial = new THREE.MeshBasicMaterial({ color: 0x7074FF })
      var plane = new THREE.PlaneBufferGeometry(window.innerWidth, window.innerHeight)
      var planeObject = new THREE.Mesh(plane, blueMaterial)
      planeObject.position.z = -15
      bufferScene.add(planeObject)

      var boxMaterial = new THREE.MeshBasicMaterial({ map:bufferTexture });
      var boxGeometry2 = new THREE.BoxGeometry( 5, 5, 5 );
      var mainBoxObject = new THREE.Mesh(boxGeometry2, boxMaterial);
      mainBoxObject.position.z = 3
      scene.add(mainBoxObject)

      const pixiTexture = PIXI.RenderTexture.create(width, height)
      pixiRenderer.bindRenderTexture(pixiTexture)
      const _glRenderTargets = pixiTexture.baseTexture._glRenderTargets
      const fbo = _glRenderTargets[Object.keys(_glRenderTargets)[0]].frameBuffer
      fbo.framebuffer = bufferTexture.__webglFramebuffer

      pixiRenderer.render(stage, null, true)
      animateAdd(() => {
        pixiRenderer.reset()
        //renderer.render(bufferScene, camera, bufferTexture)
        pixiRenderer.render(stage, pixiTexture, true)
        pixiRenderer.reset()
        renderer.state.reset()
      })
    },
    mount3: ({
      fromScene,
      width,
      height,
    }) => () => {
      const { animateAdd, renderer, scene } = fromScene

      const camera = new THREE.PerspectiveCamera(70, width / height, 1, 1000)

      const bufferScene = new THREE.Scene()
      const bufferTexture = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter })
      var redMaterial = new THREE.MeshBasicMaterial({ color: 0xF06565 })
      var boxGeometry = new THREE.BoxGeometry(5, 5, 5)
      var boxObject = new THREE.Mesh(boxGeometry, redMaterial)
      boxObject.position.z = -10;
      bufferScene.add(boxObject)

      var blueMaterial = new THREE.MeshBasicMaterial({ color: 0x7074FF })
      var plane = new THREE.PlaneBufferGeometry(window.innerWidth, window.innerHeight)
      var planeObject = new THREE.Mesh(plane, blueMaterial)
      planeObject.position.z = -15
      bufferScene.add(planeObject)

      var boxMaterial = new THREE.MeshBasicMaterial({ map: bufferTexture });
      var boxGeometry2 = new THREE.BoxGeometry(5, 5, 5);
      var mainBoxObject = new THREE.Mesh(boxGeometry2, boxMaterial);
      mainBoxObject.position.z = 3
      scene.add(mainBoxObject)

      animateAdd(() => {
        renderer.render(bufferScene, camera, bufferTexture)
      })
    },    
    mount: ({
      antialias,
      fromScene,
      rendererSet,
      stageSet,
      transparent,
      width,
      height,
      onInstanceChange,
    }) => () => {
      const { animateAdd, canvas, scene, renderer } = fromScene

      const pixiRenderer = PIXI.autoDetectRenderer(
        width,
        height,
        {
          antialias,
          transparent,
          view: renderer.domElement,
          context: renderer.context,
        }
      )
      pixiRenderer.state.blendModes[20] = [0, WebGLRenderingContext.ONE_MINUS_SRC_ALPHA]
      patchRenderTarget(pixiRenderer)

      const pixiBaseTexture = new PIXI.BaseRenderTexture(width, height, PIXI.SCALE_MODES.LINEAR, window.deviceResolution * 2)
      const pixiTexture = new PIXI.RenderTexture(pixiBaseTexture)
      const stage = new PIXI.display.Stage()
      stage.group.enableSort = true

      const texture = new THREE.Texture()
      const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })
      const geometry = new THREE.PlaneGeometry(50, 50)
      const instance = new THREE.Mesh(geometry, material)

      scene.add(instance)

      rendererSet(pixiRenderer)
      stageSet(stage)

      onInstanceChange && onInstanceChange(instance)

      // function generateMipmap(texture) {
      //   pixiRenderer.bindTexture(texture.baseTexture)
      //   const glTex = texture.baseTexture._glTextures[pixiRenderer.CONTEXT_UID]
      //   glTex.enableMipmap()
      //   glTex.enableLinearScaling()
      // }

      animateAdd(() => {
        pixiRenderer.reset()
        pixiRenderer.render(stage, pixiTexture, false)
        //generateMipmap(pixiTexture)
        pixiRenderer.reset()
        renderer.state.reset()

        let textureProps = renderer.properties.get(material.map)
        let baseTex = pixiTexture.baseTexture
        textureProps.__webglTexture = baseTex._glTextures[pixiRenderer.CONTEXT_UID].texture
      })
    },
    update: ({

    }) => () => {
    },
    layerCreate: ({ stage, layerSet }) => ({ name, index }) => {
      const group = new PIXI.display.Group(index, true)

      stage.addChild(new PIXI.display.Layer(group))

      layerSet({ name, value: group })
    },
    layerRemove: ({ stage, layers, layerUnset }) => ({ name }) => {
      stage && stage.removeChild(layers[name])
      layerUnset({ name })
    },
    textureLoad: ({ textures, textureSet }) => async ({ imageLink }) => {
      if (textures[imageLink]) return textures[imageLink]

      const texture = await new Promise((resolve, reject) => {
        if (PIXI.utils.TextureCache[imageLink]) return resolve(PIXI.utils.TextureCache[imageLink])

        const loader = new PIXI.loaders.Loader()

        loader
          .add(imageLink, imageLink)
          .load((loader, resources) => resolve(resources[imageLink].texture))
      })

      textureSet({ name: imageLink, value: texture })

      return texture
    },
  }),
  lifecycle({
    componentDidMount() {
      this.props.mount()
    },
    componentDidUpdate() {
      //this.props.update()
    }
  }),
)

const Pixi3d = enhance(({
  children,
  renderer,
  stage,
  layers, layerCreate, layerRemove,
  textures, textureLoad,  
}) => {
  return (
    <Context.Provider value={{
      renderer,
      stage,
      layers, layerCreate, layerRemove,
      textures, textureLoad,
    }}>
      {stage ? children : null}
    </Context.Provider>    
  )
})

export default Pixi3d