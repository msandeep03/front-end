import React, { Component } from 'react'
import compose              from 'recompose/compose'
import defaultProps         from 'recompose/defaultProps'
import lifecycle            from 'recompose/lifecycle'
import withHandlers         from 'recompose/withHandlers'
import withPropsOnChange    from 'recompose/withPropsOnChange'
import withStateHandlers    from 'recompose/withStateHandlers'

import * as THREE           from 'three'

import Context              from '../../scene/all/Context'
import controlTypeMap       from '../../control/api/controlTypeMap'
import ControlOrbital3d     from '../../control/web/ControlOrbital3d'
import ControlPlane3d       from '../../control/web/ControlPlane3d'


const enhance = compose(
  defaultProps({
    controlType: controlTypeMap.ORBITAL,
    far: 50000,
    intersectCheckList: [],
    near: 1,
    viewAngel: 45,
  }),
  withStateHandlers(() => ({
    camera: null,
    x: 0,
    y: 0,
    z: 0,
  }), {
    cameraSet: () => (camera) => ({ camera }),
    positionSet: () => (x, y, z) => ({ x, y, z }),
  }),
  withHandlers(({
    onIntersect,
  }) => {
    const point = new THREE.Vector2()
    const mouse = new THREE.Vector2()
    const raycaster = new THREE.Raycaster

    return {
      onMouseMove: ({
        camera,
        fromScene,
        intersectCheckList,
        positionSet,
        x, y, z,
      }) => (e) => {
        e.preventDefault()

        if (intersectCheckList.length) {
          const { container, scene } = fromScene

          const { clientX: x, clientY: y } = e
          const { left, top, width, height } = container.getBoundingClientRect()

          point.fromArray([(x - left) / width, (y - top) / height])
          mouse.set((point.x * 2) - 1, - (point.y * 2) + 1)

          raycaster.setFromCamera(mouse, camera)
          const intersectList = raycaster.intersectObjects(intersectCheckList)
          
          if (intersectList.length && intersectList[0].uv) {
            const uv = intersectList[0].object.material.map
              .transformUv(intersectList[0].uv)
            onIntersect && onIntersect({ uv, point: intersectList[0].point })
          }
        }
      },
    }
  }),
  withHandlers(() => {
    let controls

    return {
      mount: ({
        cameraSet,
        far,
        fromScene: {
          animateList,
          animateCameraSet,
          container,
          renderer,
          scene,
          width,
          height,
        },
        near,
        positionSet,
        onMouseDown,
        onMouseMove,
        onMouseUp,
        onMouseWheel,
        viewAngel,
      }) => () => {
        const camera = new THREE.PerspectiveCamera(
          viewAngel,
          width / height,
          near,
          far,
        )

        cameraSet(camera)
        //controls = new OrbitControls(camera)

        positionSet(0, 0, 60)

        container.addEventListener('mousemove', onMouseMove, false)

        animateCameraSet(() => {
          renderer.render(scene, camera)
        })
      },
      unmount: ({
        fromScene: {
          container,
        },
        onMouseDown,
        onMouseMove,
        onMouseUp,
        onMouseWheel,
      }) => () => {
        container.removeEventListener('mousemove', onMouseMove, false)  
      },
      lookAt: ({
        camera
      }) => (object) => {
        if (camera) {
          camera.lookAt(object.position)
        }
      }
    }
  }),
  withPropsOnChange(
    [`x`, `y`, `z`],
    ({ camera, x, y, z, }) => {
      if (camera) {
        camera.position.set(x, y, z)
      }
    }
  ),    
  lifecycle({
    componentDidMount() {
      this.props.mount()
    },
    componentWillUnmount() {
      this.props.unmount()
    }
  }),
)

const Camera3d = enhance(({
  camera,
  controlType,
  fromScene,
  positionSet,
  x, y, z,
}) => {
  if (!camera) return null

  return (
    <React.Fragment>
      {controlType === controlTypeMap.PLANE ? (
        <ControlPlane3d
          camera={camera}
          fromScene={fromScene}
          x={x}
          y={y}
          z={z}
          positionSet={positionSet}
        />
      ) : null}
      {controlType === controlTypeMap.ORBITAL ? (
        <ControlOrbital3d
          camera={camera}
          fromScene={fromScene}
          x={x}
          y={y}
          z={z}
          positionSet={positionSet}
        />
      ) : null}    
    </React.Fragment>
  )
})

export default (props) => {
  return (
    <Context.Consumer>
      {(context) => (
        <Camera3d {...props} fromScene={context} />
      )}
    </Context.Consumer>
  )
}